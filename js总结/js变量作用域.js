// 变量作用域
1.变量生命周期2.变量作用范围
// 静态作用域 (又称词法作用域)
由程序定义的位置决定，编译阶段就决定变量的引用，与程序定义的位置
有关，与代码执行顺序无关，一般采用嵌套作用域规则解析
var x = 10;
function foo(){
	alert(x);
}
function bar(){
	var x = 20;
	foo();
}
bar();
上面是一个静态作用域的例子，最外层是全局作用域，包括x,foo()和bar()
bar作用域中也有一个x，是局部变量，不会被foo()函数调用
foo()函数调用的x是它上层域中的全局变量
// 动态作用域
由程序运行时决定，与代码的执行顺序有关
若上述例子为动态作用域的话，
在执行时会由动态栈来管理
先执行的代码在栈底，
查找变量时，会从上往下找最近的变量
// js变量作用域
1.js使用静态作用域
2.没有块级作用域(if,for跟while不会产生作用域)
3.只有全局作用域，和函数作用域以及with，catch等特殊作用域
4.ES5使用词法环境管理静态作用域
// 词法环境
描述环境的对象
在执行代码时，首先会有一个全局环境
函数里会有自己的环境(在全局环境里，有一个outer引用指向全局环境)
函数中的函数，会有outer指向父函数环境，可以访问父函数变量和全局变量
1.环境记录
记录环境中的行参，函数声明，变量和。。。
2.对外部环境的引用outer

// 环境记录初始化--声明提前
在代码执行前，初始化环境(执行而不是声明)
声明提前指的是当代码执行前，先扫描函数内容，记录行参，函数声明和变量，定义到环境记录中
会记录行参，行参的值，var变量(不记录值，undefined，执行时赋值)，内部函数的声明(只是声明，会创建一个内部函数对象，包涵函数行参，函数体和scope属性，指向父环境，在执行时，outer=scope)，
// 函数声明与函数表达式的区别
函数声明的函数对象会提前创建，函数表达式会在执行时创建
// 词法环境－with
var foo = 'abc';
with({
	foo: "bar"//在with环境中
}){
	function f(){
		alert(foo);//全局环境
	};
	(function(){
		alert(foo);//会被执行，属于函数表达式
	})();
	f();//执行前声明，outer会在被记录的位置
}
首先创建全局环境，记录foo和f()
然后创建with环境(临时作用域，with中定义var，函数，和在外面无差别)，outer指向global
foo:"bar"
// try...catch
try{
	var e = 10;
	throw new Error();
}catch(a){
	//这里var和function声明都会被记录在全局函数中，而catch临时环境中只有a这个error
}
// js作用域－带名称的函数表达式
(function A(){
	A = 1;
	alert(A);
})();
首先是函数表达式，不一定会在全局
执行时创建词法环境，记录A,A是函数，不能被改写，alert出的还是函数A











